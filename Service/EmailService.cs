using Microsoft.VisualBasic;
using System.Text.RegularExpressions;
using testEmailModule.Utils;
using static System.Net.WebRequestMethods;

namespace testEmailModule.Service
{
    public class EmailService : IEmailService
    {
        // in-memory field to hold the timestamp, key is email
        private static Dictionary<string, (string OTP, DateTime Timestamp)> otpStore = new Dictionary<string, (string OTP, DateTime Timestamp)>();

        /* 
         *  @func generate_OTP_email sends a new 6 digit random OTP code to the given email address 
         *  input by the users. Only emails from the ".dso.org.sg" domain should be allowed to receive an OTP code.
        */
        public async Task<(EmailEnum, string)> generate_OTP_email(string? email)
        {
            if (string.IsNullOrEmpty(email))
            {
                //  STATUS_EMAIL_FAIL: email address does not exist or sending to the email has failed.
                return (EmailEnum.STATUS_EMAIL_FAIL, string.Empty);
            }

            if (ValidateEmail(email))
            {
                var random = new Random();
                var randomOTPString = random.Next(0, 999999).ToString("D6");

                // Store OTP with timestamp (for simplicity, using in-memory storage)
                otpStore[email] = (randomOTPString, DateTime.UtcNow);

                var email_body = $"You OTP Code is {randomOTPString}. The code is valid for 1 minute";

               // STATUS_EMAIL_OK: email containing OTP has been sent successfully.
                return await send_email(email, email_body);
            }
            else 
            {
                // STATUS_EMAIL_INVALID: email address is invalid.
                return (EmailEnum.STATUS_EMAIL_INVALID, string.Empty);
            }
        }

        /*
         *  @func check_OTP reads the input stream for user input of the OTP. The OTP to match is the current OTP generated by a send
         *  allows user 10 tries to enter the valid OTP. check_OTP should return after 1min if the user does not give a valid OTP. 
        */
        public async Task<(EmailEnum, string)> Check_OTP(IInputStream input, string email)
        {
            if (!otpStore.ContainsKey(email))
            {
                return (EmailEnum.STATUS_EMAIL_INVALID, "Email did not request for OTP");
            }

            const int maxAttempts = 10; // Maximum number of tries
            const int timeoutMilliseconds = 5000; // Timeout in milliseconds


            var cts = new CancellationTokenSource();
            int attempts = 0;

            try
            {
                while (attempts < maxAttempts)
                {
                    attempts++;
                    Console.WriteLine($"Attempt {attempts}/{maxAttempts}. Waiting for OTP...");

                    // Run the OTP read and timeout in parallel
                    var otpTask = input.ReadOTPAsync(CancellationToken.None); // Don't pass the token here
                    var timeoutTask = Task.Delay(timeoutMilliseconds);
                    var completedTask = await Task.WhenAny(otpTask, timeoutTask);

                    if (completedTask == timeoutTask)
                    {
                        // Timeout occurred
                        Console.WriteLine("Timeout occurred while waiting for OTP.");
                        return (EmailEnum.STATUS_OTP_TIMEOUT, "Timeout after 5 seconds");
                    }

                    // OTP input was completed
                    string userOTP = await otpTask;

                    if (userOTP == otpStore[email].OTP)
                    {
                        return (EmailEnum.STATUS_OTP_OK, "OTP is valid");
                    }
                    else
                    {
                        Console.WriteLine("Invalid OTP");
                    }
                }

                return (EmailEnum.STATUS_OTP_FAIL, "OTP is wrong after 10 tries");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                return (EmailEnum.STATUS_EMAIL_INVALID, "An error occurred");
            }
        }
        private bool ValidateEmail(string email)
        {
            return email.EndsWith(".dso.org.sg", StringComparison.Ordinal);
        }

        private async Task<string> readOTP(string input)
        {
            // to simulate waiting, you can change this to TimeSpan.FromSeconds(61) to test fail flow
            //await Task.Delay(1000);
            await Task.Delay(TimeSpan.FromSeconds(61));
            return input;
        }

        // You can assume a function send_email(email_address, email_body) is implemented.
        private async Task<(EmailEnum, string)> send_email(string email_address, string email_body)
        {
            /*
             * placeholder for logic for sending email_body to the specified email
             * assuming send_email fails, we can also return STATUS_EMAIL_FAIL here, but for simplicity sake, we will assume send_email is successful
             * 
             * STATUS_EMAIL_FAIL: email address does not exist or sending to the email has failed.
             */
            return (EmailEnum.STATUS_EMAIL_OK, email_body);
        }
    }
}
